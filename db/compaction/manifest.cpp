/**
 * all functions need lock. We add lock in PersistMeta() in flush and compaction with a global lock (db->manifest_lock_)
 *
 */
#include "version.h"
#include "manifest.h"
#include "db/pst_deleter.h"
#include <libpmem.h>
#include <set>

Manifest::Manifest(char *pmem_addr, bool recover) : start_(pmem_addr), l0_start_(start_ + sizeof(ManifestSuperMeta)), l1_start_(l0_start_ + L0MetaSize), flush_log_start_(l1_start_ + L1MetaSize), end_(start_ + ManifestSize)
{
    super_ = (ManifestSuperMeta *)pmem_addr;

    if (!recover)
    {
        super_->l0_tail = 0;
        super_->l1_tail = 0;
        super_->flush_log = {0, 0};
        super_->l0_min_valid_seq_no = 0;
        super_->l1_current_seq_no = 0;
        pmem_persist(super_, sizeof(ManifestSuperMeta));
    }
    else
    {
        printf("recover mode\n");
    }
    DEBUG("start=%lu, l0=%lu,l1=%lu,flush_log=%lu", (size_t)start_, (size_t)l0_start_, (size_t)l1_start_, (size_t)flush_log_start_);
    DEBUG("l0tail=%lu,l1tail=%lu", super_->l0_tail, super_->l1_tail);
}
Manifest::~Manifest() {}

Version *Manifest::RecoverVersion(Version *version, SegmentAllocator *allocator)
{
    PSTDeleter pst_deleter(allocator);
    // recover level0
    size_t tail = super_->l0_tail;
    PSTMeta *meta;
    uint32_t min_tree_seq = super_->l0_min_valid_seq_no;
    int max_tree_seq = min_tree_seq - 1;
    version->SetCurrentL0TreeSeq(min_tree_seq);
    DEBUG("l0_tree_seq=%u,manifest tail=%lu", min_tree_seq, tail);
    for (size_t i = 0; i < tail; i++)
    {
        meta = (PSTMeta *)GetAddr(i, 0);
        if (meta->indexblock_ptr_)
        {
            // DEBUG("recover L0 pst %u", meta->seq_no_);
            if (meta->seq_no_ >= min_tree_seq)
            {
                // valid pst
                while (max_tree_seq < (int)meta->seq_no_) // if no tree,create it
                {
                    max_tree_seq++;
                    version->AddLevel0Tree();
                    DEBUG("recover L0 tree %u", max_tree_seq);
                }
                TaggedPstMeta tmeta{
                    .meta = *meta,
                    .level = 0,
                    .manifest_position = i};
                version->InsertTableToL0(tmeta, meta->seq_no_ - min_tree_seq);
                // DEBUG("add pst %lu-%lu at L0 tree %u",__bswap_64(meta->min_key_),__bswap_64(meta->max_key_),meta->seq_no_);
            }
            else
            {
                // invalid pst, try to delete it in allocator (maybe it was deleted already)
                // because we use version to identify valid pst, maybe so many invalid psts exist
                // DEBUG("delete a unconsistent pst version=%u, position=%lu(%lu~%lu)", meta->seq_no_ , i ,__bswap_64(meta->min_key_), __bswap_64(meta->max_key_));
                pst_deleter.DeletePST(*meta);
            }
        }
    }
    version->UpdateLevel0ReadTail();

    // recover level1
    tail = super_->l1_tail;
    unsigned current_L1_version = super_->l1_current_seq_no;
    DEBUG("l1_version=%u", current_L1_version);
    for (size_t i = 0; i < tail; i++)
    {
        meta = (PSTMeta *)GetAddr(i, 1);
        if (meta->indexblock_ptr_ != 0)
        {
            if (meta->seq_no_ > current_L1_version)
            {
                // Clean new PSTs generated by an unfinished compaction during crash
                pst_deleter.DeletePST(*meta);
            }
            else
            {
                // insert it into L1 tree
                TaggedPstMeta tmeta{
                    .meta = *meta,
                    .level = 1,
                    .manifest_position = i};
                version->InsertTableToL1(tmeta);
            }
        }
    }
    pst_deleter.PersistCheckpoint();

    // clean overlapped old PSTs in L1 tree which was not been cleaned in an unfinished comapction due to crash
    version->L1TreeConsistencyCheckAndFix(&pst_deleter, this);
    return version;
}

int Manifest::AddTable(PSTMeta meta, int level)
{
    int idx = -1;
    switch (level)
    {
    case 0:
        if (!l0_freelist_.empty())
        {
            idx = l0_freelist_.front();
            l0_freelist_.pop();
        }
        else
        {
            idx = super_->l0_tail;
            if (idx * sizeof(PSTMeta) >= L0MetaSize)
            {
                L0GC();
                idx = l0_freelist_.front();
                l0_freelist_.pop();
                break;
            }
            (super_->l0_tail)++;
        }
        break;
    case 1:
        if (!l1_freelist_.empty())
        {
            idx = l1_freelist_.front();
            l1_freelist_.pop();
        }
        else
        {
            idx = super_->l1_tail;
            if (idx * sizeof(PSTMeta) >= L1MetaSize)
                ERROR_EXIT("Manifest L1 is full!");
            super_->l1_tail++;
        }
        break;
    }
    const char *ad = GetAddr(idx, level);
    pmem_memcpy_persist((void *)ad, &meta, sizeof(PSTMeta));
    pmem_persist(start_, sizeof(ManifestSuperMeta));
    return idx;
}

void Manifest::DeleteTable(int idx, int level)
{
    // DEBUG("delete table idx=%d,level=%d",idx,level);
    auto temp = PSTMeta::InvalidTable();
    const char *ad = GetAddr(idx, level);
    pmem_memcpy_persist((void *)ad, &temp, sizeof(PSTMeta));

    switch (level)
    {
    case 0:
        l0_freelist_.push(idx);
        break;
    case 1:
        l1_freelist_.push(idx);
        break;
    }
}

void Manifest::AddFlushLog(std::vector<uint64_t> &deleted_log_segment_ids)
{
    if (super_->flush_log.is_valid == 1)
    {
        ERROR_EXIT("double flushing");
    }
    LOG("add flush log %lu,%lu,%u", deleted_log_segment_ids.size(), deleted_log_segment_ids.size() * sizeof(uint64_t), OpLogSize);
    assert(flush_log_start_ + deleted_log_segment_ids.size() * sizeof(uint64_t) < end_);
    pmem_memcpy_persist((void *)flush_log_start_, deleted_log_segment_ids.data(), deleted_log_segment_ids.size() * sizeof(uint64_t));
    ManifestSuperMeta::FlushLog fl{1, deleted_log_segment_ids.size()};
    pmem_memcpy_persist(&super_->flush_log, &fl, sizeof(ManifestSuperMeta::FlushLog));
}

void Manifest::ClearFlushLog()
{
    super_->flush_log.is_valid = 0;
    pmem_persist(super_, sizeof(ManifestSuperMeta));
}

bool Manifest::GetFlushLog(std::vector<uint64_t> &deleted_log_segment_ids)
{
    if (!super_->flush_log.is_valid)
        return false;
    size_t size = super_->flush_log.length;
    deleted_log_segment_ids.resize(size);
    memcpy(deleted_log_segment_ids.data(), flush_log_start_, size * sizeof(uint64_t));
    return true;
}

inline const char *Manifest::GetAddr(int idx, int level)
{
    const char *start;
    switch (level)
    {
    case 0:
        start = l0_start_;
        break;
    case 1:
        start = l1_start_;
        break;
    default:
        ERROR_EXIT("invalid level");
    }
    assert(start + idx * sizeof(PSTMeta) < end_);
    return start + idx * sizeof(PSTMeta);
}

void Manifest::UpdateL0Version(unsigned min_seq_no)
{
    DEBUG("update L0 version = %u", min_seq_no);
    super_->l0_min_valid_seq_no = min_seq_no;
    pmem_persist(super_, sizeof(ManifestSuperMeta));
}

void Manifest::UpdateL1Version(unsigned current_seq_no)
{
    super_->l1_current_seq_no = current_seq_no;
    pmem_persist(super_, sizeof(ManifestSuperMeta));
}

unsigned Manifest::GetL0Version()
{
    return super_->l0_min_valid_seq_no;
}

void Manifest::L0GC()
{
    // clear freelist_l0_ and add all invalid position to freelist
    assert(super_->l0_tail * sizeof(PSTMeta) >= L0MetaSize);
    assert(l0_freelist_.empty());
    printf("manifest: l0 gc....\n");
    unsigned min_seq_no = super_->l0_min_valid_seq_no;
    for (int i = 0; i < super_->l0_tail; i++)
    {
        PSTMeta *meta = (PSTMeta *)GetAddr(i, 0);
        if (meta->seq_no_ < min_seq_no)
        {
            l0_freelist_.push(i);
        }
    }
    if (l0_freelist_.empty())
    {
        ERROR_EXIT("Manifest L0 is full!");
    }
}